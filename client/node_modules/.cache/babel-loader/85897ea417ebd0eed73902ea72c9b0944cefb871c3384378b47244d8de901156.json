{"ast":null,"code":"import { Reaction } from \"mobx\";\nimport React from \"react\";\nimport { printDebugValue } from \"./utils/printDebugValue\";\nimport { isUsingStaticRendering } from \"./staticRendering\";\nimport { observerFinalizationRegistry } from \"./utils/observerFinalizationRegistry\";\nimport { useSyncExternalStore } from \"use-sync-external-store/shim\";\nfunction createReaction(adm) {\n  adm.reaction = new Reaction(\"observer\".concat(adm.name), function () {\n    var _a;\n    adm.stateVersion = Symbol();\n    // onStoreChange won't be available until the component \"mounts\".\n    // If state changes in between initial render and mount,\n    // `useSyncExternalStore` should handle that by checking the state version and issuing update.\n    (_a = adm.onStoreChange) === null || _a === void 0 ? void 0 : _a.call(adm);\n  });\n}\nexport function useObserver(render, baseComponentName) {\n  if (baseComponentName === void 0) {\n    baseComponentName = \"observed\";\n  }\n  if (isUsingStaticRendering()) {\n    return render();\n  }\n  var admRef = React.useRef(null);\n  if (!admRef.current) {\n    // First render\n    var adm_1 = {\n      reaction: null,\n      onStoreChange: null,\n      stateVersion: Symbol(),\n      name: baseComponentName,\n      subscribe: function (onStoreChange) {\n        // Do NOT access admRef here!\n        observerFinalizationRegistry.unregister(adm_1);\n        adm_1.onStoreChange = onStoreChange;\n        if (!adm_1.reaction) {\n          // We've lost our reaction and therefore all subscriptions, occurs when:\n          // 1. Timer based finalization registry disposed reaction before component mounted.\n          // 2. React \"re-mounts\" same component without calling render in between (typically <StrictMode>).\n          // We have to recreate reaction and schedule re-render to recreate subscriptions,\n          // even if state did not change.\n          createReaction(adm_1);\n          // `onStoreChange` won't force update if subsequent `getSnapshot` returns same value.\n          // So we make sure that is not the case\n          adm_1.stateVersion = Symbol();\n        }\n        return function () {\n          var _a;\n          // Do NOT access admRef here!\n          adm_1.onStoreChange = null;\n          (_a = adm_1.reaction) === null || _a === void 0 ? void 0 : _a.dispose();\n          adm_1.reaction = null;\n        };\n      },\n      getSnapshot: function () {\n        // Do NOT access admRef here!\n        return adm_1.stateVersion;\n      }\n    };\n    admRef.current = adm_1;\n  }\n  var adm = admRef.current;\n  if (!adm.reaction) {\n    // First render or reaction was disposed by registry before subscribe\n    createReaction(adm);\n    // StrictMode/ConcurrentMode/Suspense may mean that our component is\n    // rendered and abandoned multiple times, so we need to track leaked\n    // Reactions.\n    observerFinalizationRegistry.register(admRef, adm, adm);\n  }\n  React.useDebugValue(adm.reaction, printDebugValue);\n  useSyncExternalStore(\n  // Both of these must be stable, otherwise it would keep resubscribing every render.\n  adm.subscribe, adm.getSnapshot, adm.getSnapshot);\n  // render the original component, but have the\n  // reaction track the observables, so that rendering\n  // can be invalidated (see above) once a dependency changes\n  var renderResult;\n  var exception;\n  adm.reaction.track(function () {\n    try {\n      renderResult = render();\n    } catch (e) {\n      exception = e;\n    }\n  });\n  if (exception) {\n    throw exception; // re-throw any exceptions caught during rendering\n  }\n  return renderResult;\n}\n//# sourceMappingURL=useObserver.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}